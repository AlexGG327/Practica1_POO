[
    "Trabajo de Christian",
    "holaa",
    "golaa",
    "a",
    "hola",
    "Hola soy Isabel",
    "Hola",
    "g",
    "mensaje, MEL",
    "Hola",
    "a",
    "Trabajo de Christian",
    "a",
    "b",
    "c",
    "c",
    "Hola soy Isabel",
    "Trabajo de Christian",
    "Hola soy Ekaitz",
    "Hola soy Ekaitz",
    "no me funciona el doom:(",
    "w",
    "noooooooooooooooooooooooooooooooo",
    "popo",
    "Hola soy Ekaitz",
    "EKAITZ",
    "Hola soy Isabel",
    "Trabajo de Christian",
    "Trabajo de Christian",
    "g",
    "Hola",
    "Hola soy Ekaitz",
    "Trabajo de Christian",
    "Trabajo de Christian",
    ",ll",
    "m",
    "m",
    "m",
    "q",
    "m",
    "m",
    "eeee",
    "jbjb",
    "jbjb",
    "donde estaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",
    "Hola soy Ekaitz",
    "i cannot move it move it anymore maurice",
    "njjj",
    "HUUOLA",
    "a",
    "Aitor",
    "tee envio un 0 0 0",
    "guada",
    "familia",
    "yo",
    "cagar",
    "donde?",
    "donde cago el conde",
    "para hacer montañita",
    "a",
    "aa",
    "pepe",
    "aaaaaaaa",
    "Hola Aitor",
    "te llega Manu??????????????????????????????????????????????",
    "\nimport cv2\nimport time\nimport rclpy\nimport numpy as np\nfrom rclpy.node import Node\nfrom cv_bridge import CvBridge\nfrom sensor_msgs.msg import Image\nfrom scipy.signal import find_peaks\nfrom std_srvs.srv import Trigger\n\nclass ImageProcessingPPG(Node):\n    def __init__(self):\n        super().__init__('ppg_service_node')\n        self.subscription = self.create_subscription(Image, 'camera/image_raw', self.listener_callback, 10)\n        self.srv = self.create_service(Trigger, 'calculate_heart_rate', self.calculate_bpm_callback)\n        self.bridge = CvBridge()\n        self.face_cascade = cv2.CascadeClassifier(cv2.data.haarcascades + 'haarcascade_frontalface_default.xml')\n        self.buffer = []\n        self.buffer_size = 300  # Adjust this based on frame rate and time window\n        self.start_time = time.time()\n        self.bpm = 0\n\n    def get_average_color(self, frame, x, y, w, h):\n        roi = frame[y:y+h, x:x+w]\n        avg_color_per_row = np.average(roi, axis=0)\n        avg_color = np.average(avg_color_per_row, axis=0)\n        return avg_color, roi\n\n    def listener_callback(self, data):\n        cv_image = self.bridge.imgmsg_to_cv2(data)\n        gray = cv2.cvtColor(cv_image, cv2.COLOR_BGR2GRAY)\n        faces = self.face_cascade.detectMultiScale(gray, 1.3, 5)\n\n        if len(faces) > 0:\n            (x, y, w, h) = faces[0]\n            forehead_x = int(x + 0.5 * w - 0.15 * w)\n            forehead_y = int(y + 0.1 * h)\n            forehead_w = int(0.3 * w)\n            forehead_h = int(0.2 * h)\n\n            avg_color, _ = self.get_average_color(cv_image, forehead_x, forehead_y, forehead_w, forehead_h)\n            green_intensity = avg_color[1]  # Use the green channel for rPPG\n\n            self.buffer.append(green_intensity)\n            if len(self.buffer) > self.buffer_size:\n                self.buffer.pop(0)\n\n    def calculate_bpm_callback(self, request, response):\n        elapsed_time = time.time() - self.start_time\n        if elapsed_time >= 10 and len(self.buffer) > 0:  # Ensure at least 10 seconds of data\n            data = np.array(self.buffer)\n            peaks, _ = find_peaks(data, distance=10)\n            num_beats = len(peaks)\n            bpm = (num_beats / elapsed_time) * 60\n            \n            self.get_logger().info(f'Calculated BPM: {bpm}')\n            response.success = True\n            response.message = f'Heart rate is {int(bpm)} BPM'\n            self.bpm = bpm\n            \n            # Reset the buffer and start time for the next calculation\n            self.start_time = time.time()\n            self.buffer = []\n        else:\n            response.success = False\n            response.message = 'Insufficient data to calculate BPM'\n\n        return response\n\ndef main(args=None):\n    rclpy.init(args=args)\n    ppg_service_node = ImageProcessingPPG()\n    rclpy.spin(ppg_service_node)\n    ppg_service_node.destroy_node()\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()",
    "probando",
    "class doom_exe:\n    def __init__(self):\n        self.topic_transmitir = \"transmitir_doom\"\n        self.topic_imputs = \"imputs_doom\"\n        self.broker = \"broker.emqx.io\"\n        self.port = 1883\n\n        self.client = mqtt.Client()\n        self.client.on_connect = self.on_connect\n        self.client.on_message = self.on_message\n        \n\n    # mensajes doom\n    def on_connect(self, client, userdata, flags, rc):\n        if rc == 0:\n            print(\"Conexión exitosa al broker MQTT\")\n            # Suscribirse a los temas\n            self.client.subscribe(self.topic_transmitir)\n            self.client.subscribe(self.topic_imputs)\n            print(f\"Suscrito al tema '{self.topic_transmitir}'\")\n        else:\n            print(f\"Error de conexión, código: {rc}\")\n            \n    # recibir mensajes\n    def on_message(self, client, userdata, msg):\n\n        if msg.topic == 'transmitir_doom':\n            print(f\"Frame recibido en '{self.topic_transmitir}'\")\n            try:\n                # Decodificar base64 a bytes\n                frame_bytes = base64.b64decode(msg.payload.decode(\"utf-8\"))\n                \n                # Convertir bytes a array NumPy\n                array = np.frombuffer(frame_bytes, np.uint8)\n                \n                # Decodificar JPEG a imagen OpenCV\n                img = cv2.imdecode(array, cv2.IMREAD_COLOR)\n                \n                \n                # Mostrar la imagen\n                cv2.imshow('DOOM - Ventana Completa', img)\n                cv2.waitKey(1)  # importante para refrescar ventana\n            except Exception as e:\n                print(\"Error decodificando frame:\", e)\n    \n    \n    def detectar_imputs(self):\n            tecla = 0\n            while True:\n                tecla = input(\"Presiona una tecla (w/a/s/d/e/space) para enviar input a DOOM.\").lower()\n                if tecla == \"w\":\n                    imput = \"W\"\n                    print(\"Movimiento adelante\")\n                if tecla == \"s\":\n                    imput = \"S\"\n                    print(\"Movimiento atrás\")\n                if tecla == \"a\":\n                    imput = \"A\"\n                if tecla == \"d\":\n                    imput = \"D\"\n                if tecla == \"e\":\n                    imput = \"SPACE\"\n                if tecla =='space':\n                    imput = \"FIRE\"\n\n                if imput is not None:\n                    self.client.publish(self.topic_imputs, imput)\n                    print(f\"Input enviado: {imput}\", flush=True)    \n                \n                time.sleep(0.05)",
    "te llega aitor",
    "popo",
    "esto furula"
]